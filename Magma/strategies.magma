clear;

//********************************************************************
//********************************************************************
//Start functions for get_parallel_strategy

Ev_Counts := function(E0, E1, k)
    //input:    E0 and E1 are sets of horizontal edges counts
    //          k is the number of cores available
    //output:   evs:   The number of evaluations required
    //                  to compute the set of edges En
    //                  when k cores are available.
    //          En:     The new set of horizontal edges 
    //                  generated by E0 and E1.
    
    //Building the new set of horizontal edges
    if IsEmpty(E0) then
        En :=  [1] cat [i : i in E1];
    else
        En := [i + 1 : i in E0] cat [1] cat E1;
    end if;
    evs := 0;
    //getting the cost of En when k cores used
    if k eq 1 then
        //if only one core is available, then the cost is 
        //the sum of all horizontal edges.
        evs := &+En;
    else
        for i in En do
            if i le k then
                //if there are at most k edges then the
                //k cores could perform all edges in parallel
                //with a single round
                evs +:= 1;
            else
                //If there are more horizontal edges than the
                //number of cores then there are necessary 
                // (i div k) rounds + 1 round for the remainder edges
                    evs +:= (i div k) + 1;
            end if;
        end for;
    end if;
    return evs, En;
end function;


get_Min_Parallel_Strat := function(C, E, M, n, p, q, k)
    //Input:    C: Set of costs.
    //          E: Set of sets of horizontal edges.
    //          M: Set of Multiplication counts.
    //          n: Number of leaves.
    //          p: Cost of one Point Multiplication by d
    //          q: Cost of one evaluation by a d-degree isogeny
    //          k: number of available cores.
    //Output:   minC:  The cost of the minimum strategy
    //                  for n leaves using k cores.
    //          minEn:  The new set of edges for the minimum 
    //                  strategy for n leaves using k cores.
    //          minM :  The multiplication counts for the minimum
    //                  strategy for n leaves using k cores.
    minC := n^2*(p+q);//just an upper bound
    for b := 1 to n-1 do
        //getting the edges and number of evaluations for the 
        //setting (n-b, b).
        ev_counts_temp, E_temp := Ev_Counts(E[n-b], E[b], k);
        //getting the number of multiplications for the
        //setting (n-b, b).
        muls_temp := (M[n-b] + M[b] + b);
        //Computing the cost for the current setting (n-b, b)         
        cost_temp := (ev_counts_temp * q) + (muls_temp * p);
        if cost_temp lt minC then
            idx := b;
            minC := cost_temp;
            minEn := E_temp;
            minM := muls_temp;
        end if;
    end for;
    return minC, idx, minEn, minM;
end function;

get_Parallel_Strategy := function(n, p, q, K)
     //Input 
    //n: Maximum number of multiplications-by-l
    //p: cost of one multiplication-by-l
    //q: cost of one l-isogeny evaluation
    //K: Number of cores availables
    //
    //Output
    //A linearized strategy suitable for parallel computing (software oriented).
    E := [[], [1]];
    M := [0, 1];
    S := [[], [1]];
    C := [0, p+q];
    for i in [3..(n+1)] do
        cost, b, Ei, muls := get_Min_Parallel_Strat(C, E, M, i, p,q, K);
        Append(~C, cost);//getting cost;//idk why XD
        Append(~E, Ei);//updating the set of sets of horizontal edges
        Append(~M, muls);//updating the set of Muls.
        Append(~S, [b] cat S[i - b] cat S[b] );
    end for;
    return S[n+1];
end function;
//End of functions for get_parallel_strategy
//********************************************************************
//********************************************************************

//********************************************************************
//********************************************************************
//Sidh specs get_strategy
serial_cost := function(n, p, q, C)
    return Min([C[(n - b)] + C[b] + b*p  + (n-b)*q: b in [1..n-1]]);
end function;

get_strategy_sike := function(n, p , q)
    S := [[]];
    C := [0];
    for i in [2..n+1] do
        cost, b := serial_cost(i, p, q, C);
        Append(~C, cost);
        Append(~S, [b] cat S[i-b] cat S[b]);
    end for;
    return S[n+1], C;
end function;
//End of sidh specs get_strategy
//********************************************************************
//********************************************************************


run_strategy := function(St, n: tikz:=false, cores:=1)
    //just the idea for running a sidh strategy
    //Input:    St:     An sidh strategy.
    //          n:      the number of leaves for the strategy
    //Output:   evc:    The number of evaluations required by St.
    //          mulc:   The number of multiplications required by St.
    idxs := [0];
    idx := 0;
    i := 1;
    mulc := 0;
    evc := 0;
    for row := 0 to n-1 do
        while idx lt n - row do
            mulc +:= St[i];
            idx +:= St[i];
            //store points;
            Append(~idxs, idx);
            i +:=1;
        end while;
        //get isogeny
        //evaluate all stored points 
        //except the kernel
        temp_evc:=0;
        for k := 1 to #idxs - 1  do
            temp_evc +:=1;
        end for;
        if cores gt 1 then
            if temp_evc le cores then
                temp_evc:= 1;
            else
                if (temp_evc mod cores) eq 0 then
                    temp_evc := (temp_evc div cores);
                else
                    temp_evc := (temp_evc div cores) + 1;
                end if;
            end if;
        end if;
        evc +:= temp_evc;
        Prune(~idxs);
        idx := idxs[#idxs];
    end for;
    return mulc, evc;
end function;

get_New_Parallel_Strategy := function(n, p, q,r, k, Cost_R, cost_inversion)
    //Input 
    //n: Maximum number of multiplications-by-l
    //p: cost of one multiplication-by-l
    //q: cost of one l-isogeny evaluation
    //r: cost of one l-isogeny construction (must include get kernel points cost)
    //k: Number of cores availables
    //Cost_R: Cost of computing the secret key P+[m]Q
    //cost_inversion: Cost of one quadratic field inversion.
    //
    //Output
    //A linearized strategy suitable for computing the private key in parallel to a portion of an strategy.
    //NOTE: This only works for Alice, i.e. with l = 4
    for i := 1 to n do
        St_temp  := get_Parallel_Strategy(i , p, q, k-1);
        m, e := run_strategy(St_temp, i : cores := k);
        C_temp := (m * p) + (e * q);
        //we need to include the cost of computing [4^(e-i)]R
        Cost_Ri_temp := (n + i) * p;
        total_Cost_temp := Cost_Ri_temp + C_temp + i*r; //cost of get d-isog
        if total_Cost_temp le Cost_R then
            Max_i := i;
            Max_St := St_temp;
        else 
            break i;
        end if;
    end for;
    St_temp  := get_Parallel_Strategy(n - Max_i - 1,p,q,k);
    m, e := run_strategy(St_temp, n - Max_i - 1 : cores := k);
    C_temp := (m * p) + (e * q);
    //cost of second triangle + cost of sending R to E_b + cost of computing R(includes cost of first triangle) + both inversions + last get d-isog
    Total_Cost := C_temp + (((Max_i + 1) + 3) div k)*q  + Cost_R + 2*cost_inversion + (n-Max_i + 1)*r;
    St := [n - Max_i] cat Max_St cat St_temp;
    return St;
end function;

